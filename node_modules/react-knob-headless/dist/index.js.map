{"version":3,"sources":["../src/KnobHeadless.tsx","../src/KnobHeadlessLabel.tsx","../src/KnobHeadlessOutput.tsx","../src/useKnobKeyboardControls.ts"],"names":["forwardRef","useDrag","mergeProps","clamp","clamp01","mapFrom01Linear","mapTo01Linear","jsx","axisDefault","includeIntoTabOrderDefault","mapTo01Default","mapFrom01Default","KnobHeadless","_a","forwardedRef","_b","valueRaw","valueMin","valueMax","dragSensitivity","valueRawRoundFn","valueRawDisplayFn","onValueRawChange","orientation","axis","includeIntoTabOrder","mapTo01","mapFrom01","rest","__objRest","value","bindDrag","delta","diff01","value01","newValue01","newValueRaw","getDragAxis","__spreadValues","getAriaOrientation","event","KnobHeadlessLabel","props","KnobHeadlessOutput","useKnobKeyboardControls","step","stepLarger","noDefaultPrevention","code","maybePreventDefault"],"mappings":"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","sourcesContent":["import {forwardRef} from 'react';\nimport {useDrag} from '@use-gesture/react';\nimport mergeProps from 'merge-props';\nimport {clamp, clamp01, mapFrom01Linear, mapTo01Linear} from '@dsp-ts/math';\n\ntype NativeDivProps = React.ComponentProps<'div'>;\n\ntype NativeDivPropsToExtend = Omit<\n  NativeDivProps,\n  | 'role' // Constant. We don't want to allow overriding this\n  | 'aria-valuemin' // Handled by \"valueMin\"\n  | 'aria-valuemax' // Handled by \"valueMin\"\n  | 'aria-valuenow' // Handled by \"valueRaw\" and \"valueRawRoundFn\"\n  | 'aria-valuetext' // Handled by \"valueRawDisplayFn\"\n  | 'aria-orientation' // Handled by \"axis\" and \"orientation\"\n  | 'aria-label' // Handled by \"KnobHeadlessLabelProps\"\n  | 'aria-labelledby' // Handled by \"KnobHeadlessLabelProps\"\n  | 'tabIndex' // Handled by \"includeIntoTabOrder\"\n>;\n\nconst axisDefault = 'y';\nconst includeIntoTabOrderDefault = false;\nconst mapTo01Default = mapTo01Linear;\nconst mapFrom01Default = mapFrom01Linear;\n\ntype KnobHeadlessLabelProps =\n  | {\n      readonly 'aria-label': string;\n    }\n  | {\n      readonly 'aria-labelledby': string;\n    };\n\ntype KnobHeadlessProps = NativeDivPropsToExtend &\n  KnobHeadlessLabelProps & {\n    /**\n     * Current raw value.\n     * Make sure it's not rounded.\n     */\n    readonly valueRaw: number;\n    /**\n     * Minimum value.\n     */\n    readonly valueMin: number;\n    /**\n     * Maximum value.\n     */\n    readonly valueMax: number;\n    /**\n     * The sensitivity of the drag gesture. Must be a positive float value.\n     * Play with this value in different browsers to find the best one for your use case.\n     * Recommended value: 0.006 (quite optimal for most scenarios, so far).\n     */\n    readonly dragSensitivity: number;\n    /**\n     * The rounding function for the raw value.\n     */\n    readonly valueRawRoundFn: (valueRaw: number) => number;\n    /**\n     * The function for mapping raw value to the human-readable text.\n     */\n    readonly valueRawDisplayFn: (valueRaw: number) => string;\n    /**\n     * Callback for when the raw value changes.\n     * Note, that you shouldn't round the value here, instead, you have to do it inside \"valueRawRoundFn\".\n     */\n    readonly onValueRawChange: (newValueRaw: number) => void;\n    /**\n     * @DEPRECATED Use \"axis\" instead.\n     *\n     * Orientation of the knob and its gesture.\n     */\n    readonly orientation?: 'horizontal' | 'vertical'; // eslint-disable-line react/require-default-props\n    /**\n     * Gesture axis of the knob.\n     * Default: \"y\".\n     */\n    readonly axis?: 'x' | 'y' | 'xy';\n    /**\n     * Whether to include the element into the sequential tab order.\n     * If true, the element will be focusable via the keyboard by tabbing.\n     * In most audio applications, the knob is usually controlled by the mouse / touch, so it's not needed.\n     */\n    readonly includeIntoTabOrder?: boolean;\n    /**\n     * Used for mapping the value to the normalized knob position (number from 0 to 1).\n     * This is the place for making the interpolation, if non-linear one is required.\n     * Example: logarithmic scale of frequency input, when knob center position 0.5 corresponds to ~ 1 kHz (instead of 10.1 kHz which is the \"linear\" center of frequency range).\n     */\n    readonly mapTo01?: (x: number, min: number, max: number) => number;\n    /**\n     * Opposite of `mapTo01`.\n     */\n    readonly mapFrom01?: (x: number, min: number, max: number) => number;\n  };\n\nexport const KnobHeadless = forwardRef<HTMLDivElement, KnobHeadlessProps>(\n  (\n    {\n      valueRaw,\n      valueMin,\n      valueMax,\n      dragSensitivity,\n      valueRawRoundFn,\n      valueRawDisplayFn,\n      onValueRawChange,\n      orientation,\n      axis = axisDefault,\n      includeIntoTabOrder = includeIntoTabOrderDefault,\n      mapTo01 = mapTo01Default,\n      mapFrom01 = mapFrom01Default,\n      ...rest\n    },\n    forwardedRef,\n  ) => {\n    const value = valueRawRoundFn(valueRaw);\n\n    /* v8 ignore start */ // eslint-disable-line capitalized-comments\n    const bindDrag = useDrag(\n      ({delta}) => {\n        let diff01 = 0.0;\n        diff01 += delta[0] * dragSensitivity;\n        diff01 += delta[1] * -dragSensitivity; // Negating the sensitivity for vertical axis (Y), since the direction of it goes top down on computer screens.\n\n        // Conversion of the raw value to 0-1 range\n        // makes the sensitivity to be independent from min-max values range,\n        // as well as it allows to use non-linear mapping functions.\n        const value01 = mapTo01(valueRaw, valueMin, valueMax);\n        const newValue01 = clamp01(value01 + diff01);\n        const newValueRaw = clamp(\n          mapFrom01(newValue01, valueMin, valueMax),\n          valueMin,\n          valueMax,\n        );\n\n        onValueRawChange(newValueRaw);\n      },\n      {\n        pointer: {\n          // Disabling default keyboard events provided by @use-gesture:\n          // https://use-gesture.netlify.app/docs/options/#pointerkeys\n          keys: false,\n        },\n        axis: getDragAxis(orientation, axis),\n      },\n    );\n    /* v8 ignore stop */ // eslint-disable-line capitalized-comments\n\n    return (\n      <div\n        ref={forwardedRef}\n        role='slider'\n        aria-valuenow={value}\n        aria-valuemin={valueMin}\n        aria-valuemax={valueMax}\n        aria-orientation={getAriaOrientation(orientation, axis)}\n        aria-valuetext={valueRawDisplayFn(valueRaw)}\n        tabIndex={includeIntoTabOrder ? 0 : -1}\n        {...mergeProps(\n          bindDrag(),\n          {\n            style: {\n              touchAction: 'none', // It's recommended to disable \"touch-action\" for use-gesture: https://use-gesture.netlify.app/docs/extras/#touch-action\n            },\n            onPointerDown(event: React.PointerEvent<HTMLElement>) {\n              /* v8 ignore start */ // eslint-disable-line capitalized-comments\n              // Touch devices have a delay before focusing so it won't focus if touch immediately moves away from target (sliding). We want thumb to focus regardless.\n              // See, for reference, Radix UI Slider does the same: https://github.com/radix-ui/primitives/blob/eca6babd188df465f64f23f3584738b85dba610e/packages/react/slider/src/Slider.tsx#L442-L445\n              event.currentTarget.focus();\n              /* v8 ignore stop */ // eslint-disable-line capitalized-comments\n            },\n          },\n          rest,\n        )}\n      />\n    );\n  },\n);\n\nKnobHeadless.displayName = 'KnobHeadless';\n\nKnobHeadless.defaultProps = {\n  axis: axisDefault,\n  includeIntoTabOrder: includeIntoTabOrderDefault,\n  mapTo01: mapTo01Default,\n  mapFrom01: mapFrom01Default,\n};\n\nconst getDragAxis = (\n  orientation: 'horizontal' | 'vertical' | undefined,\n  axis: 'x' | 'y' | 'xy',\n): 'x' | 'y' | undefined => {\n  // The prop is deprecated, but takes precedence for backwards compatibility\n  if (orientation) return orientation === 'horizontal' ? 'x' : 'y';\n\n  // \"undefined\" means no axis lock, i.e. \"xy\":\n  // https://use-gesture.netlify.app/docs/options/#axis\n  return axis === 'xy' ? undefined : axis;\n};\n\nconst getAriaOrientation = (\n  orientation: 'horizontal' | 'vertical' | undefined,\n  axis: 'x' | 'y' | 'xy',\n): React.AriaAttributes['aria-orientation'] => {\n  // The prop is deprecated, but takes precedence for backwards compatibility\n  if (orientation) return orientation;\n\n  // When using both axes, the orientation is ambiguous:\n  // https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-orientation#values\n  if (axis === 'xy') return undefined;\n  return axis === 'x' ? 'horizontal' : 'vertical';\n};\n","import {forwardRef} from 'react';\n\ntype NativeLabelProps = React.ComponentProps<'label'>;\n\ntype NativeLabelPropsToExtend = Omit<\n  NativeLabelProps,\n  'id' // We are overriding this to make it required\n>;\n\ntype KnobHeadlessLabelProps = NativeLabelPropsToExtend & {\n  readonly id: string;\n};\n\nexport const KnobHeadlessLabel = forwardRef<\n  HTMLLabelElement,\n  KnobHeadlessLabelProps\n>((props, forwardedRef) => <label ref={forwardedRef} {...props} />);\n\nKnobHeadlessLabel.displayName = 'KnobHeadlessLabel';\n","import {forwardRef} from 'react';\n\ntype NativeOutputProps = React.ComponentProps<'output'>;\n\ntype NativeOutputPropsToExtend = Omit<\n  NativeOutputProps,\n  'htmlFor' // We are overriding this to make it required\n>;\n\ntype KnobHeadlessOutputProps = NativeOutputPropsToExtend & {\n  readonly htmlFor: string;\n};\n\nexport const KnobHeadlessOutput = forwardRef<\n  HTMLOutputElement,\n  KnobHeadlessOutputProps\n>((props, forwardedRef) => <output ref={forwardedRef} {...props} />);\n\nKnobHeadlessOutput.displayName = 'KnobHeadlessOutput';\n","import {clamp} from '@dsp-ts/math';\n\ntype UseKnobKeyboardControlsProps = {\n  /**\n   * Same as `valueRaw` prop of `KnobHeadless`.\n   */\n  readonly valueRaw: number;\n  /**\n   * Same as `valueMin` prop of `KnobHeadless`.\n   */\n  readonly valueMin: number;\n  /**\n   * Same as `valueMax` prop of `KnobHeadless`.\n   */\n  readonly valueMax: number;\n  /**\n   * Step value. Typically it's 1% of the range.\n   */\n  readonly step: number;\n  /**\n   * Larger step value. Typically it's 10% of the range.\n   */\n  readonly stepLarger: number;\n  /**\n   * Same callback as `KnobHeadless` has, with \"event\" in 2nd argument.\n   */\n  readonly onValueRawChange: (\n    newValueRaw: number,\n    event: React.KeyboardEvent,\n  ) => void;\n  /**\n   * To prevent scrolling, \"event.preventDefault()\" is called when the value changes,\n   * but for most cases you don't need to change this behaviour.\n   * However, if your application needs some more customized one, you can set this prop to true and handle scroll prevention on your own.\n   */\n  readonly noDefaultPrevention?: boolean;\n};\n\nexport const useKnobKeyboardControls = ({\n  valueRaw,\n  valueMin,\n  valueMax,\n  step,\n  stepLarger,\n  onValueRawChange,\n  noDefaultPrevention = false,\n}: UseKnobKeyboardControlsProps): {onKeyDown: React.KeyboardEventHandler} => {\n  const onKeyDown: React.KeyboardEventHandler = (event) => {\n    const {code} = event;\n    switch (code) {\n      case 'ArrowUp':\n      case 'ArrowRight':\n        onValueRawChange(clamp(valueRaw + step, valueMin, valueMax), event);\n        maybePreventDefault({event, noDefaultPrevention});\n        break;\n      case 'ArrowDown':\n      case 'ArrowLeft':\n        onValueRawChange(clamp(valueRaw - step, valueMin, valueMax), event);\n        maybePreventDefault({event, noDefaultPrevention});\n        break;\n      case 'PageUp':\n        onValueRawChange(\n          clamp(valueRaw + stepLarger, valueMin, valueMax),\n          event,\n        );\n        maybePreventDefault({event, noDefaultPrevention});\n        break;\n      case 'PageDown':\n        onValueRawChange(\n          clamp(valueRaw - stepLarger, valueMin, valueMax),\n          event,\n        );\n        maybePreventDefault({event, noDefaultPrevention});\n        break;\n      case 'Home':\n        onValueRawChange(valueMin, event);\n        maybePreventDefault({event, noDefaultPrevention});\n        break;\n      case 'End':\n        onValueRawChange(valueMax, event);\n        maybePreventDefault({event, noDefaultPrevention});\n        break;\n      /* v8 ignore start */ // eslint-disable-line capitalized-comments\n      default:\n        break;\n      /* v8 ignore stop */ // eslint-disable-line capitalized-comments\n    }\n  };\n\n  return {onKeyDown};\n};\n\nconst maybePreventDefault = ({\n  event,\n  noDefaultPrevention,\n}: {\n  event: React.KeyboardEvent;\n  noDefaultPrevention: boolean;\n}): void => {\n  if (noDefaultPrevention) return;\n  event.preventDefault();\n};\n"]}